/* Statistics.vala
 *
 * Copyright 2022 Diego Iv√°n <diegoivan.mae@gmail.com>
 *
 * SPDX-License-Identifier: GPL-3.0-or-later
 */

namespace Flowtime {
    public class Statistics : GLib.Object {
        private Xml.Doc* doc = new Xml.Doc ("1.0");
        private Xml.Node* root_element;
        private string path;

        public Day? today { get; private set; default = null; }

        public List<Day> month_list = new List<Day> ();
        public List<Day> all_days = new List<Day> ();
        public List<Day> week_list = new List<Day> ();

        public string productive_day { get; private set; }

        public uint total_worktime { get; private set; }
        public uint monthly_worktime { get; set; }
        public uint weekly_worktime { get; private set; }
        public uint today_worktime { get; private set; }

        public uint total_breaktime { get; private set; }
        public uint monthly_breaktime { get; private set; }
        public uint weekly_breaktime { get; private set; }
        public uint today_breaktime { get; private set; }

        [CCode(has_construct_function = false)]
        protected Statistics () {
        }

        ~Statistics () {
            delete doc;
        }

        private static Statistics? instance = null;
        public static Statistics get_default () {
            if (instance == null) {
                instance = new Statistics ();
            }
            return instance;
        }

        construct {
            root_element = new Xml.Node (null, "statistics");
            doc->set_root_element (root_element);
            Xml.Node* comment = new Xml.Node.comment ("GENERATED BY FLOWTIME : DO NOT MODIFY");
            root_element->add_child (comment);

            retrieve_statistics.begin ();
        }

        private async void retrieve_statistics () {
            path = Path.build_filename (Environment.get_user_data_dir (), "statistics.xml");
            var file = File.new_for_path (path);

            if (!file.query_exists ()) {
                setup_new_statistics_file ();
                save ();
                return;
            }

            doc = Xml.Parser.parse_file (path);
            if (doc == null) {
                warning ("Statistics file was found but cannot be parsed");
                setup_new_statistics_file ();

                doc = new Xml.Doc ();
                doc->set_root_element (root_element);
            }

            root_element = doc->get_root_element ();
            retrieve_days ();
            save ();
        }

        private void setup_new_statistics_file () {
            root_element->new_prop ("start", new DateTime.now_utc ().format_iso8601 ());
            today = new Day ();
            root_element->add_child (today.node);
        }

        private void retrieve_days () {
            assert (root_element->name == "statistics");
            DateTime current_date = new DateTime.now_local ();

            int months_saved = settings.get_int ("months-saved");
            Day[] overpassed_days = {};

            const TimeSpan WEEK = TimeSpan.DAY * 7;
            const TimeSpan MONTH = TimeSpan.DAY * 30;

            for (Xml.Node* i = root_element->children; i != null; i = i->next) {
                if (i->type == ELEMENT_NODE) {
                    var d = new Day.from_xml (XmlUtils.get_content_node (i, "day"));
                    TimeSpan ts = current_date.difference (d.date);

                    if (ts > MONTH * months_saved) {
                        overpassed_days += d;
                        continue;
                    }

                    total_worktime += d.worktime;
                    total_breaktime += d.breaktime;
                    all_days.append (d);

                    if (ts > MONTH) {
                        continue;
                    }

                    monthly_worktime += d.worktime;
                    monthly_breaktime += d.breaktime;
                    month_list.append (d);

                    if (ts > WEEK) {
                        continue;
                    }

                    weekly_worktime += d.worktime;
                    weekly_breaktime += d.breaktime;
                    week_list.append (d);

                    if (d.date.get_day_of_year () == current_date.get_day_of_year ()) {
                        today = d;
                        today_worktime = today.worktime;
                        today_breaktime = today.breaktime;
                    }
                }
            }

            if (today == null) {
                today = new Day ();
                root_element->add_child (today.node);
                week_list.append (today);
                month_list.append (today);
                all_days.append (today);
            }

            foreach (var day in overpassed_days) {
                day.unlink ();
            }

            get_most_productive_day ();
        }

        public void add_worktime (uint time) {
            today_worktime += time;
            weekly_worktime += time;
            monthly_worktime += time;
            total_worktime += time;

            today.worktime += time;
        }

        public void add_breaktime (uint time) {
            today_breaktime += time;
            weekly_breaktime += time;
            monthly_breaktime += time;
            total_breaktime += time;

            today.breaktime += time;
        }

        private void get_most_productive_day () {
            Day most_productive = all_days.nth_data (0);
            for (int i = 1; i < all_days.length (); i++) {
                Day current = all_days.nth_data (i);
                Day last = all_days.nth_data (i-1);

                if (current.worktime >= last.worktime) {
                    most_productive = current;
                }
            }

            productive_day = most_productive.date.format ("%A");
        }

        public void save () {
            doc->save_file (path);
        }
    }
}
