/* Statistics.vala
 *
 * Copyright 2022 Diego Iv√°n <diegoivan.mae@gmail.com>
 *
 * SPDX-License-Identifier: GPL-3.0-or-later
 */

namespace Flowtime {
    public class Statistics : GLib.Object {
        private Xml.Doc* doc = new Xml.Doc ("1.0");
        private Xml.Node* root_element;
        private string path;
        public Day? today { get; private set; default = null; }

        public uint worktime_month { get; private set; }
        public uint breaktime_month { get; private set; }

        public uint total_worktime { get; private set; }

        private uint _worktime_week;
        public uint worktime_week {
            get {
                return _worktime_week;
            }
            private set {
                worktime_month += value - _worktime_week;
                _worktime_week = value;
            }
        }

        private uint _breaktime_week;
        public uint breaktime_week {
            get {
                return _breaktime_week;
            }
            private set {
                breaktime_month += value - _breaktime_week;
                _breaktime_week = value;
            }
        }

        public uint worktime_today {
            get {
                return today.worktime;
            }
            set {
                if (value < today.worktime) {
                    critical ("Worktime cannot be decreased");
                    return;
                }
                worktime_week += value - today.worktime;
                today.worktime = value;
            }
        }

        public uint breaktime_today {
            get {
                return today.breaktime;
            }
            set {
                if (value < today.breaktime) {
                    critical ("Breaktime cannot be decreased");
                    return;
                }
                breaktime_week += value - today.breaktime;
                today.breaktime = value;
            }
        }

        public List<Day> month_list = new List<Day> ();
        public List<Day> all_days = new List<Day> ();
        public List<Day> week_list = new List<Day> ();

        public string productive_day { get; private set; }

        construct {
            root_element = new Xml.Node (null, "statistics");
            doc->set_root_element (root_element);
            Xml.Node* comment = new Xml.Node.comment ("GENERATED BY FLOWTIME : DO NOT MODIFY");
            root_element->add_child (comment);
        }

        public async void retrieve_statistics () {
            path = Path.build_filename (Environment.get_user_data_dir (), "statistics.xml");
            var file = File.new_for_path (path);

            if (!file.query_exists ()) {
                setup_new_statistics_file ();
                save ();
                return;
            }

            doc = Xml.Parser.parse_file (path);
            root_element = doc->get_root_element ();
            retrieve_days ();
            save ();
        }

        private void setup_new_statistics_file () {
            root_element->new_prop ("start", new DateTime.now_utc ().format_iso8601 ());
            today = new Day ();
            root_element->add_child (today.node);
        }

        private void retrieve_days () {
            assert (root_element->name == "statistics");
            DateTime current_date = new DateTime.now_local ();

            int months_saved = settings.get_int ("months-saved");
            Day[] overpassed_days = {};

            const TimeSpan WEEK = TimeSpan.DAY * 7;
            const TimeSpan MONTH = TimeSpan.DAY * 30;

            for (Xml.Node* i = root_element->children; i != null; i = i->next) {
                if (i->type == ELEMENT_NODE) {
                    var d = new Day.from_xml (XmlUtils.get_content_node (i, "day"));
                    TimeSpan ts = current_date.difference (d.date);

                    /*
                     * Unlink and dispose if they shouldn't be used
                     */
                    if (ts > MONTH * months_saved) {
                        message ("Day %s overpassed limit, unlinking", d.date.to_string ());
                        overpassed_days += d;
                        continue;
                    }

                    total_worktime += d.worktime;
                    all_days.append (d);

                    if (ts > MONTH) {
                        continue;
                    }

                    month_list.append (d);
                    breaktime_month += d.breaktime;
                    worktime_month += d.worktime;

                    if (ts > WEEK) {
                        continue;
                    }

                    week_list.append (d);
                    _worktime_week += d.worktime;
                    _breaktime_week += d.breaktime;

                    if (d.date.get_day_of_year () == current_date.get_day_of_year ()) {
                        today = d;
                    }
                }
            }

            if (today == null) {
                today = new Day ();
                root_element->add_child (today.node);
                week_list.append (today);
                month_list.append (today);
                all_days.append (today);
            }

            foreach (var day in overpassed_days) {
                day.unlink ();
            }

            get_most_productive_day ();
        }

        private void get_most_productive_day () {
            Day most_productive = all_days.nth_data (0);
            for (int i = 1; i < all_days.length (); i++) {
                Day current = all_days.nth_data (i);
                Day last = all_days.nth_data (i-1);

                if (current.worktime >= last.worktime) {
                    most_productive = current;
                }
            }

            productive_day = most_productive.date.format ("%A");
        }

        public void save () {
            doc->save_file (path);
        }
    }
}
