/* Statistics.vala
 *
 * Copyright 2022 Diego Iv√°n <diegoivan.mae@gmail.com>
 *
 * SPDX-License-Identifier: GPL-3.0-or-later
 */

namespace Flowtime {
    public class Statistics : GLib.Object {
        private Xml.Doc* doc = new Xml.Doc ("1.0");
        private Xml.Node* root_element;
        private string path;
        public Day? today { get; private set; default = null; }

        public uint worktime_month { get; private set; }
        public uint breaktime_month { get; private set; }

        private uint _worktime_week;
        public uint worktime_week {
            get {
                return _worktime_week;
            }
            private set {
                worktime_month += value - _worktime_week;
                _worktime_week = value;
            }
        }

        private uint _breaktime_week;
        public uint breaktime_week {
            get {
                return _breaktime_week;
            }
            private set {
                breaktime_month += value - _breaktime_week;
                _breaktime_week = value;
            }
        }

        public uint worktime_today {
            get {
                return today.worktime;
            }
            set {
                // if (value < today.worktime) {
                //     critical ("Worktime cannot be decreased");
                //     return;
                // }
                worktime_week += value - today.worktime;
                today.worktime = value;
            }
        }

        public uint breaktime_today {
            get {
                return today.breaktime;
            }
            set {
                // if (value < today.breaktime) {
                //     critical ("Breaktime cannot be decreased");
                //     return;
                // }
                breaktime_week += value - today.breaktime;
                today.breaktime = value;
            }
        }

        public string productive_day { get; private set; }

        private uint[] average_worktime = new uint[7];

        construct {
            root_element = new Xml.Node (null, "statistics");
            doc->set_root_element (root_element);
            Xml.Node* comment = new Xml.Node.comment ("GENERATED BY FLOWTIME : DO NOT MODIFY");
            root_element->add_child (comment);
        }

        public async void retrieve_statistics () {
            path = Path.build_filename (Environment.get_user_data_dir (), "statistics.xml");
            var file = File.new_for_path (path);

            if (!file.query_exists ()) {
                setup_new_statistics_file ();
                save ();
                return;
            }

            doc = Xml.Parser.parse_file (path);
            root_element = doc->get_root_element ();
            retrieve_days ();
            save ();
        }

        private void setup_new_statistics_file () {
            root_element->new_prop ("start", new DateTime.now_utc ().format_iso8601 ());
            today = new Day ();
            root_element->add_child (today.node);
        }

        private void retrieve_days () {
            assert (root_element->name == "statistics");
            DateTime current_date = new DateTime.now_utc ();
            const TimeSpan WEEK = TimeSpan.DAY * 7;
            const TimeSpan MONTH = TimeSpan.DAY * 30;

            for (Xml.Node* i = root_element->children; i != null; i = i->next) {
                if (i->type == ELEMENT_NODE) {
                    var d = new Day.from_xml (XmlUtils.get_content_node (i, "day"));
                    TimeSpan ts = current_date.difference (d.date);

                    /*
                     * Unlink and dispose if they shouldn't be used
                     */
                    if (ts > MONTH) {
                        d.unlink ();
                        continue;
                    }

                    /*
                     * Register average worktime per day of the week
                     */
                    int d_week = d.date.get_day_of_week ();
                    average_worktime[d_week - 1] += d.worktime;

                    worktime_month += d.worktime;
                    breaktime_month += d.breaktime;

                    if (ts > WEEK) {
                        continue;
                    }
                    _worktime_week += d.worktime;
                    _breaktime_week += d.breaktime;

                    if (ts < TimeSpan.DAY) {
                        today = d;
                    }
                }
            }

            if (today == null) {
                today = new Day ();
            }

            get_most_productive_day ();
        }

        private void get_most_productive_day () {
            int day = 0;
            for (int i = 1; i < average_worktime.length; i++) {
                if (average_worktime[i] >= average_worktime[day]) {
                    day = i;
                }
            }

            switch (day) {
                case 0:
                    productive_day = _("Monday");
                    break;
                case 1:
                    productive_day = _("Tuesday");
                    break;
                case 2:
                    productive_day = _("Wednesday");
                    break;
                case 3:
                    productive_day = _("Thursday");
                    break;
                case 4:
                    productive_day = _("Friday");
                    break;
                case 5:
                    productive_day = _("Saturday");
                    break;
                case 6:
                    productive_day = _("Sunday");
                    break;
                default:
                    warn_if_reached ();
                    break;
            }
        }

        public void save () {
            doc->save_file (path);
        }
    }
}
